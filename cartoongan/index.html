<html>
<head>
    <!--<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.15.1/dist/tf.min.js"></script>-->
    <script src="dist/tf.js"></script>
</head>
<body>
    <style>
        img {
            max-width:320px;
            max-height:320px;
            width:auto;
            height:auto;
        }
    </style>

    <div id="container">





        <input type="file" id="files" name="files[]" multiple="">
        <img id="input" src="cat.jpg"/>
        <canvas id="output"></canvas>
    </div>
    <script>
        // tf.disableDeprecationWarnings();

        let generator;
        async function setupGenerator() {

            // const MODEL_URL = 'http://localhost:1234/tfjs_json_models/shinkai/model.json';
            const MODEL_URL = 'https://raw.githubusercontent.com/leemengtaiwan/leemengtaiwan.github.io/master/cartoongan/tfjs_json_models/shinkai/model.json';
            generator = await tf.loadGraphModel(MODEL_URL);


            console.log('generator loaded.');
            console.log('warm up generator');
            generator.predict(tf.zeros([1, 1, 1, 3])).dispose();

        }
        setupGenerator();


        async function pytorchPredict(inputImgElement) {
            let inputImgTensor = tf.browser.fromPixels(inputImgElement);
            inputImgTensor = inputImgTensor.toFloat();
            inputImgTensor = inputImgTensor.reverse(axis=2);
            inputImgTensor = tf.expandDims(inputImgTensor, 0);

            console.log('Start transformation using generator...');
            const startTime = performance.now();
            let generatedImgTensor = generator.predict(inputImgTensor);
            generatedImgTensor = tf.squeeze(generatedImgTensor, 0);
            generatedImgTensor = generatedImgTensor.reverse(axis=2);
            generatedImgTensor = generatedImgTensor.mul(0.5).add(0.5);
            console.log(generatedImgTensor);
            generatedImgTensor = tf.clipByValue(generatedImgTensor, 0, 1);
            const totalTime = performance.now() - startTime;
            console.log(`Transformation done in ${Math.floor(totalTime)}ms`);

            renderResult(generatedImgTensor);
            inputImgTensor.dispose();
        }


        async function predict(inputImgElement) {
            let inputImgTensor = tf.browser.fromPixels(inputImgElement);
            inputImgTensor = inputImgTensor.toFloat();
            inputImgTensor = tf.expandDims(inputImgTensor, 0);

            console.log('Start transformation using generator...');
            const startTime = performance.now();
            let generatedImgTensor = generator.predict(inputImgTensor);
            generatedImgTensor = tf.squeeze(generatedImgTensor, 0);

            generatedImgTensor = postProcess(generatedImgTensor);

            const totalTime = performance.now() - startTime;
            console.log(`Transformation done in ${Math.floor(totalTime)}ms`);

            renderResult(generatedImgTensor);
        }

        async function splitPredict(inputImgElement) {
            let inputImgTensor = tf.browser.fromPixels(inputImgElement);
            inputImgTensor = inputImgTensor.toFloat();

            const h = inputImgTensor.shape[0];
            const w = inputImgTensor.shape[1];
            const h_half = Math.trunc(h / 2);
            const w_half = Math.trunc(w / 2);

            const topLeft = tf.slice(inputImgTensor, [0, 0], [h_half, w_half]);
            const topRight = tf.slice(inputImgTensor, [0, w_half], [h_half, w_half]);
            const btmLeft = tf.slice(inputImgTensor, [h_half, 0], [h_half, w_half]);
            const btmRight = tf.slice(inputImgTensor, [h_half, w_half], [h_half, w_half]);

            const batchImgTensors = tf.stack([topLeft, topRight, btmLeft, btmRight]);

            console.log('splitPredict: start transformation using generator...');
            const startTime = performance.now();
            let generatedImgTensors = generator.predict(batchImgTensors);

            [tl, tr, bl, br] = tf.split(generatedImgTensors, 4);
            tl = tf.squeeze(tl, 0);
            tr = tf.squeeze(tr, 0);
            bl = tf.squeeze(bl, 0);
            br = tf.squeeze(br, 0);

            topTensor = tf.concat([tl, tr], 1);
            bottomTensor = tf.concat([bl, br], 1);

            generatedImgTensor = tf.concat([topTensor, bottomTensor], 0);
            generatedImgTensor = postProcess(generatedImgTensor);

            const totalTime = performance.now() - startTime;
            console.log(`Transformation done in ${Math.floor(totalTime)}ms`);

            renderResult(generatedImgTensor);

        }

        function renderResult(imgTensor) {
            const output_element = document.getElementById('output');
            tf.browser.toPixels(imgTensor, output_element);
        }


        function postProcess(imgTensor) {
            imgTensor = tf.clipByValue(imgTensor, -1, 1);
            imgTensor = imgTensor.add(1).div(2);
            return imgTensor;
        }

        const filesElement = document.getElementById('files');
        filesElement.addEventListener('change', evt => {
            console.log('input image changed.');
            const startTime = performance.now();
            const totalTime = performance.now() - startTime;
            console.log(`Done in ${Math.floor(totalTime)}ms`);

            let files = evt.target.files;
                // Display thumbnails & issue call to predict each image.
                for (let i = 0, f; f = files[i]; i++) {
                    // Only process image files (skip non image files)
                    if (!f.type.match('image.*')) {
                        continue;
                    }
                    let reader = new FileReader();
                    const idx = i;
                    // Closure to capture the file information.
                    reader.onload = e => {
                        let inputImgElement = document.getElementById('input');
                        console.log(inputImgElement);
                        inputImgElement.src = e.target.result;
                        inputImgElement.onload = () => pytorchPredict(inputImgElement);
                        // inputImgElement.onload = () => predict(inputImgElement);
                        // inputImgElement.onload = () => splitPredict(inputImgElement);

                        // container_block = document.getElementById('container');
                        // container_block.appendChild(inputImgElement`);
                };


                // Read in the image file as a data URL.
                reader.readAsDataURL(f);
            }
        });





    </script>

</body>
</html>